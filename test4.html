<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>
  <script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script>
</head>
<body>
  <div class="container"></div>
  <script type="text/javascript">
  /*

I have been struggling with this a lot. So I summarized everything I know now below.

*/

// Setup
var renderer, camera, scene, $container;
var w = 750;
var h = 750;

scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(75, w/h, 0.1, 10000);
camera.position.set(0,0,20);

renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(w,h);

$container = document.querySelector('.container');
$container.appendChild(renderer.domElement);

/*Data texture*/
var side = 32;
// power of two textures are better cause powers of two are required by some algorithms.
// Like ones that decide what color will pixel have if amount of pixels is less than
// amount of textels (see three.js console error when given non-power-of-two texture)

var amount = Math.pow(side, 2); // you need 4 values for every pixel in side*side plane
var data = new Uint8Array(amount);
/*
You can also use any js typed array or ArrayBuffer itself
Most popular is Uint8Array (it can contain itegers from 0 to 255)
*/
for (var i = 0; i < amount; i++) {
data[i] = Math.random()*256; // generates random r,g,b,a values from 0 to 1
/*
  When using Uint8Array multiply the random value by 255 to get same results
  'cause in that case you use integers from 0 to 255 to represent colors
  which is limiting but is more widely supported (see comment below)
*/
}
console.log(renderer.context.getExtension('OES_texture_float'));
console.log(renderer.context.getExtension('OES_texture_float_linear'));
/*
 If you got nothing, check console to see if you have this extension
 If not: use Uint8Array instead of Float32Array and THREE.UnsignedByteType istead of
 THREE.FloatType in texture constructor
*/
var dataTex = new THREE.DataTexture(data, side, side, THREE.LuminanceFormat, THREE.UnsignedByteType);
console.log(dataTex);
/*
In order to use the types THREE.FloatType and THREE.HalfFloatType, the WebGL implementation
must support the respective extensions OES_texture_float and OES_texture_half_float.
https://threejs.org/docs/index.html#Reference/Textures/DataTexture
https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Using_Extensions
*/

// also check out THREE.LinearFilter just to see the results
dataTex.magFilter = THREE.NearestFilter;

// somehow this line is required for this demo to work. I have not figured that out yet.
dataTex.needsUpdate = true;

/*Plane*/
var planeGeo = new THREE.PlaneBufferGeometry(15, 15);
var planeMat = new THREE.MeshBasicMaterial({ color: 0x4422ff, alphaMap: dataTex, transparent: true });
var plane = new THREE.Mesh(planeGeo, planeMat);
scene.add(plane);

/*Render*/
renderer.render(scene, camera);
  </script>
</body>
</html>
